# Лабораторная работа №2. Ручное построение нисходящих синтаксических анализаторов

## Вариант 6. Описание переменных в Kotlin
Блок описания переменных в языке Kotlin. Каждое описание начинается ключевым словом “var” или “val”, далее идет описание переменной.
Описание содержит имя переменной, затем двоеточие, затем имя типа.
Затем может идти начальное значение, предусмотреть инициализацию
только для типа Int числом, выражения рассматривать не требуется.\
Используйте один терминал для всех имен переменных и имен типов.
Используйте один терминал для ключевого слова var (не три ‘v’, ‘a’, ‘r’).
Пример: var a: Int; val c: Int = 2;


## 1. Грамматика для описания переменных и массивов в Kotlin:

S -> d v I E\
E -> eps\
E -> ; P\
P -> d v I E\
P -> eps\
Q -> d v\
I -> -> V\
I -> : T\
V -> n\
V -> NA\
T -> ti NI\
T -> ra NAE\
NI -> n\
NI -> eps\
NA -> a ( D )\
NAE -> a ( DE )\
D -> n C\
DE -> eps\
DE -> n C\
C -> , D\
C -> eps

### Описание нетерминальных символов:

```kotlin
enum class NonTerminal {
    S, E, NI, NA, T, NAE, D, V, DE, C, I, P, ROOT
}
```

| NonTerminal | Description                                                                                                                                                                               |
|-------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| S           | корректное выражение для объявление одной или нескольких переменных                                                                                                                       |
| E           | продолжение выражения после объявленных одной или более переменных (может отсутствовать, может принимать значение “;”, может принимать значение “;” с последующей декларацией переменных) |
| P           | пустое выражение или корректное выражение для объявление одной или нескольких переменных                                                                                                  |
| I           | часть выражения, отвечающая за опционально присутствующие типизацию и инициализацию переменной                                                                                            |
| V           | часть выражения, соответствующая инициализации переменной                                                                                                                                 |
| T           | часть выражения, отвечающая за типизацию и опционально присутствующую инициализацию переменной                                                                                            |
| NI          | часть выражения, соответствующая инициализации целочисленной переменной                                                                                                                   |
| NA          | часть выражения, соответствующая инициализации непустого массива                                                                                                                          |
| NAE         | часть выражения, соответствующая инициализации пустого или заполненного значениями массива                                                                                                |
| DE          | часть выражения, соответствующая значениям в массиве (может быть пустой в случае пустого массива)                                                                                         |
| D           | часть выражения, соответствующая значениям в массиве (не может быть пустой)                                                                                                               |
| C           | часть выражения, соответствующая запятой и последующим значениям массива или пустая строка                                                                                                |

На первый взгляд избыточное количество нетерминалов объясняется тем, что в kotlin существует множество корректных
способов объявления переменных с опциональными частями выражения, отвечающих за типизацию, инициализацию и окончание (
точка с запятой).\
Например:

```kotlin
var a = 5;
var a = 5
var a: Int = 5;
var a: Int = 5
var a: Int;
var a: Int
var a: Array<Int>;
var a: Array<Int>
var a: Array<Int> = arrayOf(1, 2);
var a: Array<Int> = arrayOf(1, 2)
var a: Array<Int> = arrayOf()
var a: Array<Int> = arrayOf();
var a: = arrayOf(1, 2)
var a: = arrayOf(1, 2);

var a: = arrayOf()  // а это уже некорректно
```

## 2. Построение лексического анализатора

### Терминальные символы:

```kotlin
enum class Token {
    DECLARATION, COLON, EQUAL, EPS,
    SEMICOLON, NUM, TYPE_INT, TYPE_ARRAY, VARIABLE, EOF,
    ARRAY, RIGHT_BRACKET, LEFT_BRACKET, COMMA
}
```

| Terminal                                                 | Token         |
|----------------------------------------------------------|---------------|
| var / val (в грамматике - d)                 DECLARATION |
| :                                                        | COLON         |
| =                                                        | EQUAL         |
| ;                                                        | SEMICOLON     |
| целочисленная переменная (в грамматике - n)              | NUM           |
| Int (в грамматике - ti)                                  | TYPE_INT      |
| Array<Int> (в грамматике - ta)                           | TYPE_ARRAY    |
| название переменной (в грамматике - v)                   | VARIABLE      |
| arrayOf (в грамматике - a)                               | ARRAY         |
| (                                                        | LEFT_BRACKET  |
| )                                                        | RIGHT_BRACKET |
| ,                                                        | COMMA         |

код для Лексического анализатора в файле [LexAnalyzer](src/main/kotlin/LexAnalyzer.kt)

## 3. Построение синтаксического анализатора

### множества FIRST и FOLLOW:

| NonTerminal | FIRST         | FOLLOW   |
|-------------|---------------|----------|
| S           | { d }         | { $ }    |
| E           | { eps, ; }    | { $ }    |
| P           | { eps, d }    | { $ }    |
| I           | { =, : }      | { $, ; } |
| V           | { n, a, eps } | { $, ; } |
| T           | { ti, ta }    | { $, ; } |
| NI          | { =, eps }    | { $, ; } |
| NA          | { a, eps }    | { $, ; } |
| NAE         | { =, eps }    | { $, ; } |
| DE          | { n, eps }    | { ) }    |
| D           | { n }         | { ) }    |
| C           | { **,**, eps  | { ) }    |

код для Лексического анализатора в файле [LexAnalyzer](src/main/kotlin/ExpressionParser.kt)

## 4. Построение дерева разбора

Код для генерации изображения дерева разбора см в файле [LexAnalyzer](src/main/kotlin/MyNode.kt)\
Сгенерированное изображение по умолчанию кладется в папку ```graphs```

Для генерации изображений необходимо добавить ```implementation("guru.nidi:graphviz-java:0.16.0")``` в зависимости.

## 5. Тесты

см [LexAnalyzer](src/test/kotlin/MyClassTest.kt)